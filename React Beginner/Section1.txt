Quiz 1

1. What are the two problems React tries to solve?
Adding dynamic data and user interactions to update our HTML; to pass data to react and recieve HTML views as a result. 
2. What is the main difference between React and jQUery?
jQuery uses queries to manipulate the DOM directly, this is an issue because it results in tons of lines and very slow code without optimized algorithms. React, on the otherhand, uses a virtual DOM (VDOM) which is a series of javascript objects that resemble the structure of the real DOM. React replaces the entire DOM but has optimizations set to make it incredibly fast.
3. How does React simplify your code?
React makes code alot simpler because queries do not have to be used directly. The addition of JSX also makes code more readable. 

Quiz 2
1. What JavaScript language construct is used to implement virtual DOM elements in React?
objects
2. What field is used in React to set a class for the elements?
className: {}, because class is a reserved word in javascript 
3. How are interactions implemented in React?
With synthetic user event handlers such as onClick, OnKeydown, etc. These allow us to add event handlers to objects we created.

How actual React objects look like (VDOM elements):
let reactElement = {
  // the $$typeof property tells react that this object is a react element and that react should use it to create an element
  $$typeof:magicValue,
  // the ref property holds a reference to the corresponding DOM element after the react element is rendered to the DOM, if we arent using it, it must be set to null.
  ref: null,
  // the type property defines the HTML- tag we want to generate
  type: "h1",
  // The props property defines properties that get passed down to the element
  props: {
    // We are passing down a text node here as a child
    children:"Hello, world!",
    // passing a class to the element 
    className: "abc",
    // Adding CSS styles
    style:{
      textAlign: "center"
    },
    // Adding event handlers via synthetic events:
    onClick: function(event){
      alert(`${event.target} has been clicked`);
    }
  }

}

1. Element Factory
It's quite cumbersome to need to create an object for every single react element we create. We can instead use the react helper function, React.createElement() which will automatically add the $$type and ref attributes for our elements each time we call them

Instead of the object we created before, we can type:

let anotherElement = React.createElement(
  "p",
  null,
  "A nice text paragraph"
)

The inputs are: 1. the type of element to create, 2. The props of the element including: event handlers, styles, dynamic data (must be null if no props are used), 3. The children of the element such as text nodes, you can add another react element here to do classic DOM nesting.

A more complex example:
let reactElement = React.createElement(
  // Type of element
  "h1",
  // All of our props excluding our children
  {
    // Classes to attach to element
    className: "abc",
    // Styles of the element
    style: {
      textAlign: "center"
    },
    // Event handlers
    onClick: function(){
      alert("click");
    }
  },
  // Child element aka text node in this case
  "Hello, world!"
)

// The normal object notation form of this example is the example above!

Quiz 3
1. What are the three arguments the React.createElement() function accepts?
  1. Type of element, h1, p, etc 
  2. Props of the element 
  3. Children of the element, can be a text node or another element entirely 
2. What does the React.createElement() function return?
  React element objects 
3. What does the React.createElement add that we need to do manually when using element objects
  Special identifiers such as $$typeof and ref 


  Part 2 - JSX
  JSX is React's version of template languages used to create markup that embedds HTML with JavaScript. It does however come with a major drawback: it needs an extra compiling step to run in a browser. If we want to use JSX with react, we must use a JavaScript compiler like Babel which usually compiles newer JavaScript code to earlier versions that is useable by all browsers. In the JSX case, Babel compiles our JSX code down to regular JavaScript such as the React.createElement() calls we used before.

  To setup Babel, we need to include the babel compiler into our application by adding it through a script tag then instructing babel to compile our JSX to javascript:

  Babel script tag:
  <script src="https://unpkg.com/@babel/standalone/babel.min.js">

  In order to instruct babel to compile our custom JSX code, we must write our JSX inside a separate script tag formatted like this:
  <script type="text/babel">
  your code 
  </script>
  or
  <script type="text/babel" src="index.js" />

  Writing JSX 
  let anotherElement = <p>A nice text paragraph</p>;

  the above is compiled to the following:
  anotherElement = React.createElement(
    "p",
    null,
    "A nice text paragraph"
  );

  Creating complex elements
  JSX lets us create complex elements, not just the base HTML tags we're used to. If we use lowercase tags, babel will pass the corresponding string to React.createElement(), such as: if we write <p></p>, babel will pass the string "p" to create a paragraph element. We can however create custom elements by passing uppercase elements, this will pass a variable to the function call. This lets us create custom elements such as: <CustomElement />. We can also insert the tags we put into React.createElement by passing them like HTML tags <CustomElement style={{backgroundColor: "red"}} />, if no props are passed, null will be passed in the createElement function call.

  Example:
  let reactElement = (
    <h1 className="abc" style={{ textAlign: "center" } onClick={function(){
      alert("click");
    }}}>
    Hello, world!
    </h1>
  )
  Note that we can embedd javascript directly in JSX using curly braces

  We can also pass in custom props via propName="value", these props can be passed down to embedded elements.

Another example of using Javascript with JSX:
<h1>{loggedIn ? `Hello {userName}!` : "Please sign in!"}</h1>
This will render hello username if the used is logged in or please sign in if they aren't into an h1 tag!

Quiz
1. What extra tool is needed to run JSX code?
Babel, a compiler. 
2. To what JavaScript construct is a JSX element compiled to?
Normal javascript code in the form of a React.createElement() function call 
3. How can we execute regular JavaScript inside JSX?
By placing the regular JavaScript in curly braces such as <h1>{isMale? "Hey bro" : "Hi girlbro";} </h1>


Part 3 - Nested elements
One of the most powerful features of JSX is its ability to nest elements 

I. Nesting with Pure JSX
  To regularly nest without JSX, we would have to do something like this:
  React.createElement(
    "p",
    null,
    React.createElement(
      "strong",
      null,
      "Bold text"
    )
    );
  Doing this several times would make our code difficult to read and incredibly long, especially in long production applications. 
With JSX we can instead do this:

<p> <strong>Bold text</strong> </p>

For elements with multiple children:
<p> Hi <strong>Bold text</strong> ! </p>
Since there isn't further nesting, the react.createElement() call would look like this:

React.createElement(
  "p",
  null,
  "Hi ",
  React.createElement("strong",null,"Bold Text"),
  "!"
)
As you can see, if an element has multiple children, we simply add them as extra arguments into the createElement function 

II. Nesting with JavaScript
We can insert JavaScript into JSX using curly braces so we can also nest with JavaScript in JSX!
Example 
///////////////////
let myClass = "abc";

function myText() {
  return "world";
}

let reactElement = (
  <div className={myClass}>
    <h1>Hello {10*10}</h1>
    <h2>{myText()}</h2>
  </div>
)
///////////////////

The above renders the following HTML:
<div class="abc">
  <h1>Hello 100</h1>
  <h2>world</h2>
</div>

NOTE, if we use JavaScript in JSX it MUST have some value. We cannot pass statements or functions that do not return a value! Instead of statements, the ternary operator is highly preferred!

Nesting allows us to create complex element structures without losing flexibility that comes with templating languages. JSX lets us use the full power of JavaScript while templating languages limit JavaScript usage!

1. What do nested JSX elements compile to?
A React.createElement with another React.createElement call given as one of its child arguments (third argument onward)
2. Can JavaScript be used inside JSX's curly braces?
Yes

Part 4 - Components

I. Functional components - basic stateless components. Basically a simple function with an uppercase name that contains some JSX code.

Instead of storing our components in variables as we've done before, we can create a functional component. This solves two problems, if we want to use the element in some other JSX code, we do not have to use curly braces and the data isnt encapsulated.

Example:
** Note the same of the component MUST start with uppercase or we CANNOT use it without curly braces in JSX 

let MyComponent = () => {
  let data = "world";
  return(
    <div>
      <h1>Hello</h1>
      <h2>{data}</h2>
    </div>
  )
}

Remember that Babel looks at the casing of the first letter of the JSX and passes it into React.createElement() either as a string if it's lowercase or as a variable if it is uppercase. In this case it passes a variable which is a reference to the functional component MyComponent.

When we create components we can then reuse them in JSX. For example, we can now do something like this:

<div className="greeting">
  <div>Here is a greeting:</div>
  <MyComponent/>
</div>

renders as:
<div class="greeting"> 
  <div>Here is a greeting:</div> 
  <div> 
    <h1>Hello</h1> 
    <h2>world</h2> 
  </div> 
</div>

We can create a ton of these components and give them special logic and use them as the building blocks of our page.

In React, the general rule of thumb is to keep each component in it's own file and import it into another file if we ever need to use it. Typically the variable name of the import would be the same as the name of the file. REMEMBER to use UpperCases!

Note: if we do use Uppercases, aka components, they must satisfy two requirements:

1. There must exist a variable within the scope the the JSX calling that component, aka if the JSX <MyComponent/> appears on the page, there must exist a variable on the page called MyComponent that is either imported or hard coded on the page 
2. The variable MUST be a function that returns an element, an array of elements or null.

Returning a list of elements
If we want to render a list of elements we can return the elements in an array or in a React.Fragment

Example
function MyComponent(){
  let data = "world";
  return [<h1 key="hello">Hello</h1>, <h2 key="data">{data}</h2>];

}

if we do this, each element must have a unique key property which will help React determine the position of multiple elements in one array. This means if we change on element in the array, React can directly access that element via key rather than replacing every single element. 

We can also use React.Fragment instead of an array if we want to return multiple elements and do not want to keep track of key props or use commas:
function MyComponent(){
  let data = "world";
  return(
    <React.Fragment>
      <h1>Hello</h1>
      <h2>{data}</h2>
    </React.Fragment>
  )
}

Quiz
1. What improvement do functional components bring over regular functions that return elements?
Functional components let us create reusable custom elements that can be integrated into JSX without curly braces and allow for the encapsulation of component-specific data or elements. 

2. What's the major constraint of a components name?
All components must start with an uppercase letter or babel will pass it into React.createElement() as a string and not as a reference to the actual component

3. What do arrays of element need to be updated efficiently by React?
All the elements within an array must have a unique key property so that React can directly access it in the case that the user changes that specific piece of data. This allows React to update without changing all the other data as well. 

Part 5 - Props 
In this section we will learn how to pass data from outside into a component 

I. Call-Site Props 

We already used props previously
<p className="black-text style={{ fontSize: 42}}></p>
in this case, the properties className and style are both props, properties of the element passed into React.createElement()

Note, we can also pass props into custom elements we create 

let reactElement = <MyComponent className="abc" customData="world" />

Note: we can pass more than strings as props, if we use curly braces we can pass all kinds of data structures and data types. 

These props that look like regular HTML properties are called call-site props. This means that these props are at the area that calls our component in JSX;they are embedded in the area where we call the component!

II. Definition-site Props
We can use props inside components like this:

function MyComponent(props){
  return(
    <div className={props.className}>
      <h1>Hello</h1>
      <h2>{props.customData}</h2>
    </div>
  )
}

All functional components recieves a props objects which is passed to the React.createElement() function as its first argument

III. Default Props 
We can also declare default properties as follows:
MyComponent.defaultProps = {
  customData: "default-data",
  className: "default-class"
}

IV. Customizing Components with Props 
Props allows us to re-use components and give them special configurations: 


// Definition, Here we definte a button prop and use a switch to change a certain property based on the props it recieves 
function Button(props) { 
  var style = { 
    color: "white", backgroundColor: "red"
     };

switch (props.size) {
   case "s": 
    style.height = 30; 
    style.width = 50; 
    break; 
  case "l": 
    style.height = 50; 
    style.width = 100; 
  break; 
  default: 
    style.height = 40; 
    style.width = 75; 
  }
return ( 
  <button style={style} onClick={props.onClick}> Click Me! </button> );
}
// Usage - Here we are calling the button component but using a different size prop to render different types of buttons
<Button size="s" onClick={function() { alert("!!!"); }} /> 
<Button onClick={function() { alert("!!!"); }} /> <Button size="l" onClick={function() { alert("!!!"); }} />
V. Special Cases 
There are two special cases for props usage:
  1. Boolean Props 
     If we do not define a value for a prop, it will get the value true. This is similar to regular html properties.

     Example
     <MyComponent active />

     becomes:

     React.createElement(MyComponent, {active:true});
  2. Props Spreading
     We can use the javascript spread operator to spread an object onto a React component which allows for a dynamic amount of props to be passed to an element which can save us alot of time 

     Example 
     let props = {
       className: "abc",
       customData: "world"
     }

     reactElement = <MyComponent {...props} />

     MyComponent gains the props className and customData!

     We can use this in large applications where we dont necessarily want to use every prop and can instead use logic to decide what props to actually pass

     - Props are used to pass state data from parent components to children 
     - Function props are used to pass state from children to parents 
     - React does NOT use two-way binding, data is transfered unidirectionally through props (parent -> child) or function calls (child -> parent)
Quiz 
1. What are props used for in React?
Props are used to pass data from outside of a component into the component. More specifically, to transfer state from parent to child.
2. Does React use two-way binding?
NO, two-way binding does not exist in React. Data flow is unidirectional. Either state from parent to child via props or from child to parent through  function props. 
3. What do function props accomplish in React?
They pass state information back up to the parent component.